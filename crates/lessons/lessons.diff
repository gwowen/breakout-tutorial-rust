diff -w lesson-3/src/ball.rs lesson-4/src/ball.rs
31,33c31,33
<         if self.rect.y > screen_height() - self.rect.h {
<             self.vel.y = -1f32;
<         }
---
>         // if self.rect.y > screen_height() - self.rect.h {
>         //     self.vel.y = -1f32;
>         // }
diff -w lesson-3/src/block.rs lesson-4/src/block.rs
4a5,10
> #[derive(PartialEq)]
> pub enum BlockType {
>     Regular,
>     SpawnBallOnDeath,
> }
> 
7a14
>     pub block_type: BlockType,
11c18
<     pub fn new(pos: Vec2) -> Self {
---
>     pub fn new(pos: Vec2, block_type: BlockType) -> Self {
14a22
>             block_type
19c27,28
<         let color = match self.lives {
---
>         let color = match self.block_type {
>             BlockType::Regular => match self.lives {
21a31,32
>             },
>             BlockType::SpawnBallOnDeath => GREEN,
diff -w lesson-3/src/main.rs lesson-4/src/main.rs
0a1,2
> use std::vec;
> 
7,8c9,69
< use block::{Block, BLOCK_SIZE};
< use ball::Ball;
---
> use block::{Block, BlockType, BLOCK_SIZE};
> use ball::{Ball, BALL_SIZE};
> 
> pub enum GameState {
>     Menu,
>     Game,
>     LevelCompleted,
>     Dead,
> }
> 
> pub fn draw_title_text(text: &str) {
>     draw_text_ex(
>         text,
>         40.0,
>         40.0,
>         TextParams {
>             font_size: 30u16,
>             color: BLACK,
>             ..Default::default()
>         },
>     );
> }
> 
> fn init_blocks(blocks: &mut Vec<Block>) {
>     let (width, height) = (6, 6);
>     let padding = 5f32;
>     let total_block_size = BLOCK_SIZE + vec2(padding, padding);
>     let board_start_pos = vec2((screen_width() - (total_block_size.x * width as f32)) * 0.5f32, 50f32);
> 
>     for i in 0..width * height {
>         let block_x = (i % width) as f32 * total_block_size.x;
>         let block_y = (i / width) as f32 * total_block_size.y;
>         blocks.push(Block::new(board_start_pos + vec2(block_x, block_y),
>         BlockType::Regular,
>         ));
>     }
>     for _ in 0..3 {
>         let rand_index = rand::gen_range(0, blocks.len());
>         blocks[rand_index].block_type = BlockType::SpawnBallOnDeath;
>     }
> }
> 
> fn reset_game(
>     score: &mut i32,
>     player_lives: &mut i32,
>     blocks: &mut Vec<Block>,
>     balls: &mut Vec<Ball>,
>     player: &mut Player,
> ) {
>     *player = Player::new();
>     *score = 0;
>     *player_lives = 3;
>     balls.clear();
>     balls.push(Ball::new(vec2(
>         screen_width() * 0.5f32 - BALL_SIZE * 0.5f32,
>         screen_height() * 0.5f32,
>     )));
>     blocks.clear();
>     init_blocks(blocks);
> }
> 
39a101,104
>     let mut game_state = GameState::Menu;
>     let mut score = 0;
>     let mut player_lives = 3;
> 
44,54d108
<     let (width, height) = (6, 6);
<     let padding = 5f32;
<     let total_block_size = BLOCK_SIZE + vec2(padding, padding);
<     let block_start_pos = vec2((screen_width() - (total_block_size.x * width as f32)) * 0.5f32, 50f32);
< 
<     for i in 0..width * height {
<         let block_x = (i % width) as f32 * total_block_size.x;
<         let block_y = (i / width) as f32 * total_block_size.y;
<         blocks.push(Block::new(block_start_pos + vec2(block_x, block_y)));
<     }
< 
55a110
>     init_blocks(&mut blocks);
57a113,120
> 
>         match game_state {
>             GameState::Menu => {
>                 if is_key_pressed(KeyCode::Space) {
>                     game_state = GameState::Game;
>                 }
>             }
>             GameState::Game => {
62a126
>                 let mut spawn_later = vec![];
67a132,139
>                             if block.lives <= 0 {
>                                 score += 10;
>                                 if block.block_type == BlockType::SpawnBallOnDeath {
>                                     spawn_later.push(Ball::new(ball.rect.point()));
>                                 }
>                             }
>                         }
>                     }
68a141,157
> 
>                 for ball in spawn_later.into_iter() {
>                     balls.push(ball);
>                 }
> 
>                 let balls_len = balls.len();
>                 let was_last_ball = balls_len == 1;
>                 balls.retain(|ball| ball.rect.y < screen_height());
>                 let removed_balls = balls_len - balls.len();
>                 if removed_balls > 0 && was_last_ball {
>                     player_lives -= 1;
>                     balls.push(Ball::new(
>                         player.rect.point()
>                         + vec2(player.rect.w * 0.5f32 - BALL_SIZE * 0.5f32, -50f32)
>                     ));
>                     if player_lives <= 0 {
>                         game_state = GameState::Dead;
72a162,179
>                 if blocks.is_empty() {
>                     game_state = GameState::LevelCompleted;
>                 }
>             }
>             GameState::Dead | GameState::LevelCompleted => {
>                 if is_key_pressed(KeyCode::Space) {
>                     game_state = GameState::Menu;
>                     reset_game(
>                         &mut score, 
>                         &mut player_lives, 
>                         &mut blocks, 
>                         &mut balls, 
>                         &mut player
>                     );
>                 }
>             }
>         }
>         
81c188,226
<         next_frame().await
---
> 
>         // draw text
>         match game_state {
>             GameState::Menu => {
>                 draw_title_text("Press space to start!");
>             },
>             GameState::Game => {
>                 let score_text = format!("Score: {}", score);
>                 draw_text_ex(
>                     &score_text,
>                     40.0,
>                     40.0,
>                     TextParams {
>                         font_size: 30u16,
>                         color: BLACK,
>                         ..Default::default()
>                     },
>                 );
> 
>                 let player_lives_text = format!("Lives: {}", player_lives);
>                 draw_text_ex(
>                     &player_lives_text,
>                     screen_width() / 2.0,
>                     40.0,
>                     TextParams {
>                         font_size: 30u16,
>                         color: BLACK,
>                         ..Default::default()
>                     },
>                 );
>             },
>             GameState::LevelCompleted => {
>                 draw_title_text(&format!("You win! Score: {}", score));
>             },
>             GameState::Dead => {
>                 draw_title_text(&format!("You died! Score: {}", score));
>             },
>         }
>         next_frame().await;
